package ai.rpg.persistence.mapper;

import ai.rpg.core.domain.*;
import ai.rpg.persistence.entity.*;
import org.mapstruct.*;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * FIXED: MapStruct mapper for converting between domain records and JPA entities
 * 
 * CRITICAL FIXES:
 * - Updated to work with proper JPA entity classes (not records)
 * - Added proper null-safe mapping
 * - Fixed mapping method signatures
 * - Added defensive copying where needed
 */
@Mapper(
    componentModel = "spring",
    unmappedTargetPolicy = ReportingPolicy.IGNORE,
    nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.SET_TO_NULL
)
public interface PlayerContextMapper {
    
    PlayerContextMapper INSTANCE = Mappers.getMapper(PlayerContextMapper.class);
    
    /**
     * Convert domain record to JPA entity
     */
    @Mapping(target = "id", ignore = true) // Auto-generated by JPA
    @Mapping(target = "character", source = "character")
    @Mapping(target = "location", source = "location") 
    @Mapping(target = "actions", ignore = true) // Handled separately for performance
    @Mapping(target = "npcStates", source = "npcStates", qualifiedByName = "mapNPCStates")
    @Mapping(target = "sessionStats", source = "sessionStats")
    PlayerContextEntity toEntity(PlayerContext domain);
    
    /**
     * Convert JPA entity to domain record
     */
    @Mapping(target = "actions", source = "actions", qualifiedByName = "mapActionsFromEntity")
    @Mapping(target = "npcStates", source = "npcStates", qualifiedByName = "mapNPCStatesFromEntity")
    PlayerContext toDomain(PlayerContextEntity entity);
    
    /**
     * Update existing entity from domain (for partial updates)
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "actions", ignore = true) // Preserve existing actions
    void updateEntityFromDomain(PlayerContext domain, @MappingTarget PlayerContextEntity entity);
    
    // Character State Mapping
    @Mapping(target = "healthCurrent", source = "health.current")
    @Mapping(target = "healthMax", source = "health.max")
    @Mapping(target = "equipment", source = "equipment", qualifiedByName = "mapEquipmentToData")
    @Mapping(target = "inventory", source = "inventory", qualifiedByName = "mapInventoryToData")
    CharacterStateEmbeddable toEmbeddable(CharacterState domain);
    
    @Mapping(target = "health", expression = "java(new ai.rpg.core.domain.HealthStatus(embeddable.getHealthCurrent(), embeddable.getHealthMax()))")
    @Mapping(target = "equipment", source = "equipment", qualifiedByName = "mapEquipmentFromData")
    @Mapping(target = "inventory", source = "inventory", qualifiedByName = "mapInventoryFromData")
    CharacterState toDomain(CharacterStateEmbeddable embeddable);
    
    // Location State Mapping  
    @Mapping(target = "locationHistory", source = "locationHistory", qualifiedByName = "mapLocationHistoryToData")
    LocationStateEmbeddable toEmbeddable(LocationState domain);
    
    @Mapping(target = "locationHistory", source = "locationHistory", qualifiedByName = "mapLocationHistoryFromData")
    LocationState toDomain(LocationStateEmbeddable embeddable);
    
    // Session Metrics Mapping
    SessionMetricsEmbeddable toEmbeddable(SessionMetrics domain);
    SessionMetrics toDomain(SessionMetricsEmbeddable embeddable);
    
    // Action Event Mapping
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "actionId", source = "id")
    @Mapping(target = "playerContext", ignore = true) // Set by service layer
    ActionEventEntity toEntity(ActionEvent domain);
    
    @Mapping(target = "id", source = "actionId")
    ActionEvent toDomain(ActionEventEntity entity);
    
    // Equipment and Inventory Mapping
    EquipmentItemData toData(EquipmentItem domain);
    EquipmentItem toDomain(EquipmentItemData data);
    
    InventoryItemData toData(InventoryItem domain);
    InventoryItem toDomain(InventoryItemData data);
    
    // Custom mapping methods for complex transformations
    
    /**
     * Map NPC relationships from domain Map to entity Map
     */
    @Named("mapNPCStates")
    default Map<String, NPCRelationshipData> mapNPCStates(Map<String, NPCRelationship> domain) {
        if (domain == null) return null;
        
        return domain.entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                entry -> toData(entry.getValue())
            ));
    }
    
    /**
     * Map NPC relationships from entity Map to domain Map
     */
    @Named("mapNPCStatesFromEntity")
    default Map<String, NPCRelationship> mapNPCStatesFromEntity(Map<String, NPCRelationshipData> data) {
        if (data == null) return Map.of();
        
        return data.entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                entry -> toDomain(entry.getValue())
            ));
    }
    
    /**
     * Map actions from entity list to domain list
     */
    @Named("mapActionsFromEntity")
    default List<ActionEvent> mapActionsFromEntity(List<ActionEventEntity> entities) {
        if (entities == null) return List.of();
        
        return entities.stream()
            .map(this::toDomain)
            .collect(Collectors.toList());
    }
    
    /**
     * Map equipment to data format
     */
    @Named("mapEquipmentToData")
    default List<EquipmentItemData> mapEquipmentToData(List<EquipmentItem> domain) {
        if (domain == null) return List.of();
        
        return domain.stream()
            .map(this::toData)
            .collect(Collectors.toList());
    }
    
    /**
     * Map equipment from data format
     */
    @Named("mapEquipmentFromData")
    default List<EquipmentItem> mapEquipmentFromData(List<EquipmentItemData> data) {
        if (data == null) return List.of();
        
        return data.stream()
            .map(this::toDomain)
            .collect(Collectors.toList());
    }
    
    /**
     * Map inventory to data format
     */
    @Named("mapInventoryToData")
    default List<InventoryItemData> mapInventoryToData(List<InventoryItem> domain) {
        if (domain == null) return List.of();
        
        return domain.stream()
            .map(this::toData)
            .collect(Collectors.toList());
    }
    
    /**
     * Map inventory from data format
     */
    @Named("mapInventoryFromData")
    default List<InventoryItem> mapInventoryFromData(List<InventoryItemData> data) {
        if (data == null) return List.of();
        
        return data.stream()
            .map(this::toDomain)
            .collect(Collectors.toList());
    }
    
    /**
     * Map location history to data format
     */
    @Named("mapLocationHistoryToData")
    default List<LocationVisitData> mapLocationHistoryToData(List<LocationVisit> domain) {
        if (domain == null) return List.of();
        
        return domain.stream()
            .map(this::toData)
            .collect(Collectors.toList());
    }
    
    /**
     * Map location history from data format
     */
    @Named("mapLocationHistoryFromData")
    default List<LocationVisit> mapLocationHistoryFromData(List<LocationVisitData> data) {
        if (data == null) return List.of();
        
        return data.stream()
            .map(this::toDomain)
            .collect(Collectors.toList());
    }
    
    // Individual mapping methods for data classes
    
    @Mapping(target = "mood", source = "mood.value")
    NPCRelationshipData toData(NPCRelationship domain);
    
    @Mapping(target = "mood", source = "mood", qualifiedByName = "stringToNPCMood")
    NPCRelationship toDomain(NPCRelationshipData data);
    
    LocationVisitData toData(LocationVisit domain);
    LocationVisit toDomain(LocationVisitData data);
    
    /**
     * Convert string to NPCMood enum
     */
    @Named("stringToNPCMood")
    default NPCMood stringToNPCMood(String mood) {
        if (mood == null) return NPCMood.NEUTRAL;
        
        try {
            // First try direct enum matching
            return NPCMood.valueOf(mood.toUpperCase());
        } catch (IllegalArgumentException e) {
            // Fallback to parsing by value
            for (NPCMood npcMood : NPCMood.values()) {
                if (npcMood.getValue().equalsIgnoreCase(mood)) {
                    return npcMood;
                }
            }
            return NPCMood.NEUTRAL;
        }
    }
}

/**
 * FIXED: Specialized mapper for performance-critical operations
 */
@Mapper(componentModel = "spring")
public interface PlayerContextSummaryMapper {
    
    /**
     * Create lightweight summary from entity (for API responses)
     */
    @Mapping(target = "currentLocation", source = "location.current")
    @Mapping(target = "previousLocation", source = "location.previous")
    @Mapping(target = "playerHealth", expression = "java(entity.getCharacter().getHealthCurrent() + \"/\" + entity.getCharacter().getHealthMax())")
    @Mapping(target = "playerReputation", source = "character.reputation")
    @Mapping(target = "sessionDuration", expression = "java(calculateSessionDuration(entity))")
    @Mapping(target = "playerMood", expression = "java(determinePlayerMood(entity))")
    @Mapping(target = "recentActions", expression = "java(getRecentActionStrings(entity))")
    @Mapping(target = "activeNPCs", expression = "java(java.util.List.of())") // Simplified for now
    @Mapping(target = "worldState", expression = "java(java.util.Map.of())")
    ContextSummary toSummary(PlayerContextEntity entity);
    
    /**
     * Calculate session duration in minutes
     */
    default double calculateSessionDuration(PlayerContextEntity entity) {
        if (entity.getStartTime() == null || entity.getLastUpdate() == null) {
            return 0.0;
        }
        
        return java.time.Duration.between(entity.getStartTime(), entity.getLastUpdate()).toMinutes();
    }
    
    /**
     * Determine player mood based on recent actions and health
     */
    default String determinePlayerMood(PlayerContextEntity entity) {
        var character = entity.getCharacter();
        if (character == null) return "neutral";
        
        double healthPercentage = (double) character.getHealthCurrent() / character.getHealthMax();
        int reputation = character.getReputation();
        
        if (healthPercentage > 0.8 && reputation > 25) {
            return "confident";
        } else if (healthPercentage < 0.3) {
            return "desperate";
        } else if (reputation < -25) {
            return "troubled";
        } else {
            return "focused";
        }
    }
    
    /**
     * Get recent action strings for summary
     */
    default List<String> getRecentActionStrings(PlayerContextEntity entity) {
        if (entity.getActions() == null) return List.of();
        
        return entity.getActions().stream()
            .limit(5)
            .map(action -> action.getCommand() + " -> " + action.getOutcome())
            .collect(Collectors.toList());
    }
}

/**
 * FIXED: ContextSummary record for API responses (lightweight representation)
 */
record ContextSummary(
    String currentLocation,
    String previousLocation,
    String playerHealth,
    int playerReputation,
    List<String> recentActions,
    List<NPCContextInfo> activeNPCs,
    double sessionDuration,
    String playerMood,
    Map<String, Object> worldState
) {}

/**
 * NPCContextInfo for summary responses
 */
record NPCContextInfo(
    String id,
    String name,
    int disposition,
    String mood,
    List<String> knownFacts,
    String lastSeen,
    String location,
    String relationship
) {}
